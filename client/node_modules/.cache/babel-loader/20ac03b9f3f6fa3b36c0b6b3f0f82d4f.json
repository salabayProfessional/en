{"ast":null,"code":"var _jsxFileName = \"/Users/macbookpro/Documents/trainee/client/src/pages/Main/Main.tsx\",\n    _s = $RefreshSig$();\n\nimport React, { useEffect } from \"react\";\nimport Proposition from \"../../component/Proposition/Proposition\";\nimport axios from \"axios\";\nimport \"./Main.scss\";\nimport { Carousel } from \"reactstrap\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst Main = () => {\n  _s();\n\n  useEffect(() => {\n    const options = {\n      method: 'GET',\n      url: 'https://google-translate20.p.rapidapi.com/translate',\n      params: {\n        text: 'One idea behind Java\\'s automatic memory management model is that programmers should be spared the burden of having to perform manual memory management. In some languages the programmer allocates memory to create any object stored on the heap and is responsible for later manually deallocating that memory to delete any such objects. If a programmer forgets to deallocate memory or writes code that fails to do so in a timely fashion, a memory leak can occur: the program will consume a potentially arbitrarily large amount of memory. In addition, if a region of memory is deallocated twice, the program can become unstable and may crash. Finally, in non garbage collected environments, there is a certain degree of overhead and complexity of user-code to track and finalize allocations.',\n        tl: 'hi',\n        sl: 'en'\n      }\n    };\n    axios.get('https://google-translate20.p.rapidapi.com/translate/?hl=uk&sl=en&text=just').then(response => {\n      console.log(response.data);\n    }).catch(function (error) {\n      console.error(error);\n    });\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"page\",\n    children: [/*#__PURE__*/_jsxDEV(Carousel, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 29,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Proposition, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 30,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 28,\n    columnNumber: 5\n  }, this);\n};\n\n_s(Main, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n\n_c = Main;\nexport default Main;\n\nvar _c;\n\n$RefreshReg$(_c, \"Main\");","map":{"version":3,"sources":["/Users/macbookpro/Documents/trainee/client/src/pages/Main/Main.tsx"],"names":["React","useEffect","Proposition","axios","Carousel","Main","options","method","url","params","text","tl","sl","get","then","response","console","log","data","catch","error"],"mappings":";;;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,OAAOC,WAAP,MAAwB,yCAAxB;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,OAAO,aAAP;AACA,SAASC,QAAT,QAAyB,YAAzB;;;AAEA,MAAMC,IAAc,GAAG,MAAM;AAAA;;AAE3BJ,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMK,OAAO,GAAG;AACdC,MAAAA,MAAM,EAAE,KADM;AAEdC,MAAAA,GAAG,EAAE,qDAFS;AAGdC,MAAAA,MAAM,EAAE;AACNC,QAAAA,IAAI,EAAE,qxBADA;AAENC,QAAAA,EAAE,EAAE,IAFE;AAGNC,QAAAA,EAAE,EAAE;AAHE;AAHM,KAAhB;AAUAT,IAAAA,KAAK,CAACU,GAAN,CAAU,4EAAV,EAAwFC,IAAxF,CAA8FC,QAAD,IAAmB;AAC9GC,MAAAA,OAAO,CAACC,GAAR,CAAYF,QAAQ,CAACG,IAArB;AACD,KAFD,EAEGC,KAFH,CAES,UAAUC,KAAV,EAAiB;AACxBJ,MAAAA,OAAO,CAACI,KAAR,CAAcA,KAAd;AACD,KAJD;AAKD,GAhBQ,EAgBN,EAhBM,CAAT;AAkBA,sBACE;AAAK,IAAA,SAAS,EAAC,MAAf;AAAA,4BACE,QAAC,QAAD;AAAA;AAAA;AAAA;AAAA,YADF,eAEE,QAAC,WAAD;AAAA;AAAA;AAAA;AAAA,YAFF;AAAA;AAAA;AAAA;AAAA;AAAA,UADF;AAMD,CA1BD;;GAAMf,I;;KAAAA,I;AA4BN,eAAeA,IAAf","sourcesContent":["import React, { useEffect } from \"react\";\nimport Proposition from \"../../component/Proposition/Proposition\";\nimport axios from \"axios\";\nimport \"./Main.scss\";\nimport { Carousel } from \"reactstrap\";\n\nconst Main: React.FC = () => {\n\n  useEffect(() => {\n    const options = {\n      method: 'GET',\n      url: 'https://google-translate20.p.rapidapi.com/translate',\n      params: {\n        text: 'One idea behind Java\\'s automatic memory management model is that programmers should be spared the burden of having to perform manual memory management. In some languages the programmer allocates memory to create any object stored on the heap and is responsible for later manually deallocating that memory to delete any such objects. If a programmer forgets to deallocate memory or writes code that fails to do so in a timely fashion, a memory leak can occur: the program will consume a potentially arbitrarily large amount of memory. In addition, if a region of memory is deallocated twice, the program can become unstable and may crash. Finally, in non garbage collected environments, there is a certain degree of overhead and complexity of user-code to track and finalize allocations.',\n        tl: 'hi',\n        sl: 'en'\n      }\n    };\n    \n    axios.get('https://google-translate20.p.rapidapi.com/translate/?hl=uk&sl=en&text=just').then((response: any) => {\n      console.log(response.data);\n    }).catch(function (error) {\n      console.error(error);\n    });\n  }, []);\n\n  return (\n    <div className=\"page\">\n      <Carousel />\n      <Proposition />\n    </div>\n  );\n};\n\nexport default Main;\n"]},"metadata":{},"sourceType":"module"}